The `deploy` command in Unity UGS CLI is used to apply configuration changes to Unity Gaming Services (UGS). It allows developers to push updates to services such as Cloud Code, Remote Config, Cloud Save, and more. This command is particularly useful for automating deployments in CI/CD pipelines, ensuring that changes to UGS configurations are versioned and consistently applied across environments.

I will gather more details on its specific parameters, expected behavior, and best practices for using it within a wrapper. Expect a detailed breakdown soon.

# Unity Gaming Services CLI `deploy` Command – Detailed Explanation

## High-Level Overview

The Unity Gaming Services (UGS) CLI provides a unified way to manage various Unity Gaming Services from the command line. Within this CLI, the `deploy` command plays a crucial role in **deploying configuration files** for existing UGS services to the cloud backend. In essence, `ugs deploy` takes local configuration assets (like Cloud Code scripts, Remote Config settings, Economy definitions, etc.) and publishes them to your Unity project’s environment on the Unity servers ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend)). This allows developers to **treat UGS configurations as code** and manage them outside the Unity Editor, enabling version control and automation.

**How it fits in the UGS ecosystem:** The `deploy` command is part of UGS CLI’s workflow for cloud content management. Instead of manually configuring services through the Unity Dashboard or Unity Editor, you can author configuration files locally and then use `ugs deploy` to push those changes to Unity’s cloud. It's particularly useful in a CI/CD context – for example, you might run `ugs deploy` during an automated build or deployment pipeline to ensure the latest game configurations (Cloud Code scripts, Remote Config values, etc.) are applied to the correct environment. In fact, the UGS CLI is designed to integrate with automated build pipelines (CI/CD) so you can promote configurations as part of your deployment process ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend)). Key use cases include: 

- **Cloud Code updates:** Deploying new or updated Cloud Code scripts and modules to make them live in the cloud environment (so game clients can call the latest logic) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=ugs%20deploy%20)).  
- **Remote Config changes:** Rolling out new configuration values or settings (feature flags, tuning parameters, etc.) by deploying JSON config files, instead of updating them manually in the dashboard ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Run%20command%20from%20Samples%2FDeploy%20directory%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,key%22%3A%20%22FLOAT%22)).  
- **Economy and other services:** Managing game economies (currencies, inventory items, purchases), leaderboards, access control policies, matchmaking config, triggers, scheduler tasks, etc., by maintaining their definitions as files and using a single deploy command to publish them ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend)).  
- **Multi-environment configuration:** Ensuring that *development*, *staging*, and *production* environments have the appropriate configurations by deploying to different targets (using the `--environment-name` option or preset config), which helps in promoting configurations from testing to live with minimal risk.  

In summary, `ugs deploy` is the mechanism to **promote local configuration changes to Unity Gaming Services**. It aligns with an Infrastructure-as-Code approach for game backend services, fitting neatly into automated workflows and reducing manual effort.

## Technical Breakdown

### Syntax and Purpose  
The basic syntax for the command is: 

```bash
ugs deploy <paths> [options]
``` 

Here, `<paths>` can be one or multiple file or directory paths containing UGS configuration files. For example, you might have a project structure with subfolders for each service (e.g., `CloudCode/`, `RemoteConfig/`, etc.); you can point `ugs deploy` to those directories, or simply use `.` to deploy everything in the current directory and its subdirectories ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=%60,to%20deploy%20the%20current%20directory)). **Authentication is required** to use this command ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=Authentication%20Required%3A%20)) (the CLI must be logged into an account with access to the project – see *Best Practices* and *Wrapper Considerations* for details on authentication).

**Example usage:** If you have a local folder `UGSConfig/` that contains subfolders for each service’s config, you could deploy all of them with one command: 

```bash
# Deploy all UGS configurations in the current directory (and subdirectories)
ugs deploy . -p <YOUR_PROJECT_ID> -e <ENVIRONMENT_NAME>
``` 

This would scan the current directory for any supported config files (Cloud Code scripts, Remote Config JSON, etc.) and deploy them to the specified Unity project (`<YOUR_PROJECT_ID>`) and environment (`<ENVIRONMENT_NAME>`). You can also deploy only specific services or folders by specifying paths or using filters (see **Options** below).

### Supported Services and File Types  
The `deploy` command is versatile – it recognizes configuration files for multiple UGS components. According to Unity’s documentation, it currently supports deploying to the following services ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend)):

- **Remote Config** – JSON files (usually with a `.rc` extension) that define key-value pairs and data types for Remote Config entries ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,key%22%3A%20%22FLOAT%22)).  
- **Cloud Code Scripts** – JavaScript files (e.g., `.js`) for Cloud Code *serverless functions*. Each script should export a function and parameter definitions (using `module.exports`) to be deployable ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Cloud%20Code%20Script)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%2F%2F%20Please%20define%20your%20script,)).  
- **Cloud Code Modules** – Precompiled modules (`.ccm` files) or C# source projects (identified by a solution file `.sln` with a publish profile) that represent Cloud Code modules to deploy as cloud logic ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Cloud%20Code%20Module)).  
- **Economy** – Definitions for economy objects like currencies, inventory items, purchases, etc., typically in JSON files with specific extensions: `.ecc` for currency, `.eci` for inventory item, `.ecv` for virtual purchase, `.ecr` for real-money purchase ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=There%20are%204%20file%20formats,for%20Economy)). Each file contains the JSON schema for that resource (name, properties, etc.), which the CLI uses to create or update the corresponding Economy item ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=File%3A%20GOLD)).  
- **Leaderboards** – Leaderboard configurations in `.lb` JSON files, including properties like sort order, update type, reset schedule, tiering config, etc. (follows a specific schema URL in the JSON) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Leaderboards%20Files%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,)).  
- **Access (Access Control)** – Access policy files (with `.ac` extension) defining project-level access control rules in JSON (who or what roles can access which resources) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Access%20Files%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=,)).  
- **Triggers** – Event or Cloud Code Triggers definitions (likely `.tr` files) that define reactions to events or schedules. These can be created via CLI (`ugs triggers new-file`) and then deployed ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Triggers%20Files%3A)).  
- **Scheduler** – Scheduled job configurations (not explicitly shown in the snippet above, but listed as supported ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend))). This likely uses a specific file format (possibly included in triggers or separate).  
- **Matchmaker** – Matchmaking service configurations, split into environment configs (`.mme` files) and queue definitions (`.mmq` files) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=You%20will%20find%20the%20resource,the%20configured%20project%20and%20environment)). These JSON files describe matchmaker rules, queue settings, etc., which the CLI will push to the Matchmaker service.  

When you run `ugs deploy`, the CLI scans the provided path(s) for files corresponding to these known types and services. It then **invokes the appropriate Unity Service APIs under the hood** to create or update the resources in your project. For example, deploying a folder with a `Script.js` (Cloud Code script) will result in that script being uploaded to the Cloud Code service of your project (and you would see `Script.js` appear in the Unity Dashboard’s Cloud Code section for that project/environment) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=ugs%20deploy%20)). Likewise, a `.rc` Remote Config file would be parsed and its entries published to the Remote Config service (so those keys and values become available in that environment) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Run%20command%20from%20Samples%2FDeploy%20directory%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,key%22%3A%20%22FLOAT%22)). 

**Multiple paths and full-project deployment:** You can specify multiple directories or files in one command, and `ugs deploy` will handle all of them. For instance, you might separate different services into different folders and call: `ugs deploy CloudCode/ RemoteConfig/ Economy/ -e development`. There is also a convenient way to deploy **everything** at once – by pointing to a parent directory (or using `.` for current directory). In Unity’s sample, running `ugs deploy .` in the root `Deploy` samples folder will deploy *all* supported content found in subdirectories ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Run%20command%20from%20Samples%2FDeploy%20directory%3A)). This all-in-one approach is useful for initial project setup or bulk promotions between environments.

### Options (Parameters) and Behavior

The `deploy` command supports several options to control its behavior. Here are the key parameters and their usage (as listed in documentation ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=Alias%20Description%20project,to%20perform%20the%20command%20on))):

- **`-p, --project-id <ID>`** – Specifies the Unity Cloud Project ID to operate on. This is the GUID of your Unity project (visible in the Unity Dashboard). If you don’t provide this, the CLI will use whatever project is set in your local config (via `ugs config set project-id`) or environment variable. **This is crucial in CI/CD** to ensure the command targets the correct project.  
- **`-e, --environment-name <name>`** – Specifies the target Unity environment name (such as `development`, `staging`, or `production`). Unity projects support multiple named environments for services, and this option tells `deploy` which environment’s configurations to update ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=Alias%20Description%20project,to%20perform%20the%20command%20on)). Like project-id, this can be set in config (`ugs config set environment-name`) or via the `UGS_CLI_ENVIRONMENT_NAME` environment variable.  
- **`-s, --services <name(s)>`** – Filters which services to deploy. You can provide one or multiple service names here (comma-separated or repeated) to indicate that only those services’ config files should be processed ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=reconcile,to%20perform%20the%20command%20on)). For example, `-s "Cloud Code, Remote Config"` would deploy only Cloud Code and Remote Config files, ignoring other files in the paths. This is useful if you want to deploy specific types of content without touching others. *(Note: When using the `--reconcile` flag, specifying `--services` becomes mandatory ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,reconcile%60%20flag)) ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=%2A%20New%20option%20%60,reconcile%60%20flag)), ensuring the CLI knows which service to reconcile.)*  
- **`--dry-run`** – Performs a trial run without actually making any changes ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=reconcile,to%20perform%20the%20command%20on)). This will go through the motions of reading files and computing what *would* be deployed, and it will output the planned actions (e.g., which resources would be created or updated) but **does not push anything to the server**. Use this to preview changes and catch mistakes before affecting live data. In a CI pipeline, a dry run could be used as a validation step.  
- **`--reconcile`** – Ensures the target environment “matches” the local content, by creating any missing content at the root (default) environment if it’s not updated in the target. In simpler terms, reconcile mode attempts to handle content that exists in the target environment but has no corresponding local file: instead of deleting it outright, the CLI will move or recreate that content in the root environment ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=quiet,to%20perform%20the%20command%20on)). This helps preserve data while clearing out the target environment. This is an advanced option typically used to **clean up** an environment so it only has what’s under source control locally. (For safety, it requires specifying a particular service via `--services` to avoid sweeping changes across all services ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,reconcile%60%20flag)).)  
- **`-q, --quiet`** – Runs with minimal logging output ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=environment,run%20with%20no%20changes%20made)). Only essential information or errors will be printed. This is handy for keeping CI logs clean or if you only care about the result status.  
- **`-j, --json`** – Outputs results in JSON format ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=environment,to%20perform%20the%20command%20on)). Instead of human-readable text, the CLI will print a JSON structure detailing the deployment outcome. This is extremely useful for integration – a script or an AI tool can parse the JSON to understand which files were deployed, or if any errors occurred. The JSON typically contains an array of results for each file or resource deployed, including statuses like “Created”, “Updated”, or “Failed”, along with identifiers. *(Under the hood, UGS CLI separates log messages and JSON output into different streams: log messages go to stderr and the JSON data goes to stdout, so you can capture the JSON cleanly without noise ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,file%2C%20publish)).)*  
- **`-h, --help`** – Displays help information about the `deploy` command. This will list usage, arguments, and options for quick reference ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=Alias%20Description%20project,Reduce%20logging%20to%20a%20minimum)).

**Expected Inputs:** The inputs to `ugs deploy` are the file(s) or directory path(s) you provide. These files should be prepared in the correct format for their respective service (as described earlier). In most cases they are JSON files following Unity’s schema definitions for that service. If the files are misnamed or malformed, the CLI will likely throw an error indicating the issue (for example, a JSON parsing error, or an unrecognized schema). It’s best to use Unity’s examples or schema documentation as a guide when creating these files. Unity provides sample files and even commands (like `ugs triggers new-file`) to scaffold them ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Triggers%20Files%3A)). The CLI identifies the service either by file extension or by certain markers in the file content (e.g., `$schema` URLs inside JSON) to route it to the correct API.

**Expected Output:** On a successful deploy, the CLI will output a summary of actions for each file/resource. In normal (text) mode, you might see a list of files with statuses such as “Created”, “Updated”, or “Unchanged”, etc., and any errors for files that failed. For example, deploying a new Cloud Code script might output a line indicating the script was created on the server, whereas deploying an unchanged Remote Config file might indicate no changes. If the `--json` flag is used, the output will be a JSON array or object containing details of each operation (file path, resource ID, status, and messages). This structured output can be parsed by tools to verify that the deploy succeeded for all items. In case of errors (e.g., network issues, invalid file content, permission issues), the command will print error messages (with details on which file or service failed) and return a non-zero exit code. You should handle such error cases (the CLI’s stderr will have logs, and in JSON mode, error entries will appear in the output). Always check the final exit status or output to ensure everything deployed as expected.

### Interaction with UGS Services

Under the hood, `ugs deploy` acts as a client to various Unity Service APIs. It reads your local files and calls the corresponding service’s REST API or Admin API to apply those configurations. Here’s how it generally interacts with each type of service:

- **Cloud Code**: For each script file, the CLI calls the Cloud Code service to upload the script (or update an existing one of the same name). For modules (`.ccm` or C# projects), it uploads the module binary or triggers a build if needed. After deployment, the scripts/modules are **published** in the target environment (similar to clicking “Publish” in the Cloud Code UI) so that they become live ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=ugs%20deploy%20)).  
- **Remote Config**: The CLI reads the `.rc` JSON, which contains one or more config entries, and uses the Remote Config API to create/update those entries in the environment. Typically, each key in the JSON becomes a Remote Config entry with its value and type. The deploy might replace the entire set of entries in that environment with the ones from your file (so ensure your file has all needed keys) – or it may do incremental updates; the exact behavior can depend on whether you use `--reconcile`. Without reconcile, it will update existing keys or add new ones defined in the file, but won’t remove entries not present in the file. With reconcile, it would move those extra entries to the root environment to sync exactly with the file. After deployment, you can log into the Unity Dashboard -> Remote Config and see the updated list of entries for that environment ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Run%20command%20from%20Samples%2FDeploy%20directory%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,key%22%3A%20%22FLOAT%22)).  
- **Economy, Leaderboards, etc.**: These services have “definition” APIs. For each JSON file (currency, inventory item, leaderboard, etc.), the CLI either creates a new resource (if it doesn’t exist) or updates the existing one (matched by some key, often the file name or an ID inside). For example, an Economy currency file named `GOLD.ecc` will create or update a currency item with ID “GOLD” ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=File%3A%20GOLD)). A leaderboard `.lb` file will create a leaderboard with the specified name and settings ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Leaderboards%20Files%3A)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=%7B%20%22%24schema%22%3A%20%22https%3A%2F%2Fugs,)). The CLI likely batch-sends these to avoid rate limits ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=Added)) (the changelog notes added batching to prevent “Too Many Requests”).  
- **Access Control**: The `.ac` policy file is sent to the Access Control service (UGS Access) which defines player or user permissions. Deploying it will update the project’s access policy according to the JSON rules (for instance, defining which actions a Player can or cannot do) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=To%20create%20a%20deployable%20access,file%20with%20the%20following%20pattern)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=,%7D)).  
- **Matchmaker**: The CLI will call the Matchmaker Admin API to update the environment configuration and queue settings from your `.mme` and `.mmq` files ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=You%20will%20find%20the%20resource,the%20configured%20project%20and%20environment)). Essentially, it’s programmatically doing what you could do via the Dashboard’s matchmaker config UI.  
- **Scheduler & Triggers**: These services orchestrate events and scheduled tasks. The `.tr` trigger file, once deployed, is sent to the UGS Triggers service, which updates the set of triggers in that environment (e.g., linking Cloud Code scripts to certain events, or setting up a schedule) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Deploy%20Triggers)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Create%20Triggers%20Files%3A)). Scheduler configurations would similarly schedule Cloud Code scripts to run at specified times. After deploying, those schedules/triggers become active in the environment’s backend.

From a developer perspective, you don’t need to call each service individually – `ugs deploy` figures out which service APIs to call based on your files, and it handles them in one consolidated operation. It also **publishes resources as part of deployment** where applicable (for example, Cloud Code scripts need publishing to be callable by clients, and the deploy command covers that step automatically ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,module.exports.parameters%20%3D)) ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,been%20modified%20to%20match%20each))). This unified deployment means you can confidently sync your local config to Unity’s cloud with one command, and is much more efficient than manual updates.

## Best Practices for Using `deploy`

To use the `deploy` command effectively, especially in team and CI/CD scenarios, consider the following best practices:

- **Organize your configuration files clearly:** Structure your repository so that UGS config files are in known locations (e.g., a top-level `UnityServicesConfig/` folder with subfolders for CloudCode, RemoteConfig, etc., similar to the sample structure ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=Run%20command%20from%20Samples%2FDeploy%20directory%3A))). This makes it easy to point `ugs deploy` to the right path. You can even include a “deployment definition” file (`.ddef`) to group files logically, but that’s optional unless your project is large. The key is to keep things tidy and under version control so that what’s on your machine is a true representation of what should be on the cloud. 

- **Use source control and sync regularly:** Treat UGS config files like code. When changes are made via the Unity Dashboard or elsewhere, use `ugs fetch` to pull them down into files, and commit those. When making changes locally, test them and then deploy. This ensures your Git (or other VCS) has the ground truth. In a collaborative setting, this prevents one developer’s local changes from accidentally overwriting another’s – if everyone goes through source control and CI deploys, you get a single source of truth.

- **Leverage multiple environments:** Unity’s environments (e.g., *Development*, *Production*) allow you to test configurations safely. Use the `-e/--environment-name` option (or set a default via config) to deploy to a non-production environment first. For example, deploy to a **staging environment** for QA to verify the new Cloud Code script or economy changes, before promoting the same files to production. You can have your CI pipeline run `ugs deploy` against a dev environment on every commit, and maybe require a manual approval or merge to run it against production. This staged approach minimizes risk.

- **Automate in CI/CD with service accounts:** For truly reliable and repeatable deployments, set up your CI pipeline (e.g., GitHub Actions, Jenkins, etc.) to run `ugs deploy`. Use a Unity **Service Account** for authentication rather than personal accounts. Create a service account in the Unity Dashboard, give it the necessary roles/permissions for the project (e.g., roles that allow updating Cloud Code, Remote Config, etc. – typically an Administrator or specific service roles) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=1,to%20deploy%20for%20different%20services)), and then use its credentials in the CLI. You can either call `ugs login` non-interactively (by passing `--service-key-id` and feeding the secret via `--secret-key-stdin`) or, even easier, set environment variables `UGS_CLI_SERVICE_KEY_ID` and `UGS_CLI_SERVICE_SECRET_KEY` in your CI environment ([Login | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/login/#:~:text=To%20log%20in%20manually%20use,command)) ([Login | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/login/#:~:text=To%20log%20in%20with%20system,to%20your%20system%27s%20environment%20variables)). This way, the CLI will automatically authenticate on each run using those keys. Also set `UGS_CLI_PROJECT_ID` and `UGS_CLI_ENVIRONMENT_NAME` env variables (or run `ugs config set project-id ...`) in the pipeline so you don’t have to specify them every time ([Configuration Keys | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/configuration/configuration-keys/#:~:text=The%20table%20below%20describes%20the,and%20the%20environment%20variable%20keys)) ([Configuration Keys | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/configuration/configuration-keys/#:~:text=ConfigKey%20EnvironmentKey%20Meaning%20%60project,Disables%20sending%20telemetry%20when%20set)). This reduces the chance of deploying to the wrong project or environment. 

- **Use `--dry-run` in your process**: When introducing `ugs deploy` into your workflow, especially for destructive changes or complex updates, do a dry run first (`ugs deploy <paths> --dry-run`). The CLI will output what it **would** do. Review this output (or have your CI log it). It’s a safe way to catch issues like “Oops, this will delete a Remote Config key that’s not in my file” or “This economy item is going to be created with default values because I missed some fields.” After reviewing, you can run the actual deploy without `--dry-run`. In automated workflows, you might even have a step where a dry run output is checked or approved before proceeding.

- **Be cautious with `--reconcile`:** This flag is powerful for cleaning up, but understand its effect. Reconcile will move any config that your local deployment **doesn’t** cover into the root environment (essentially removing it from the target environment) ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=quiet,to%20perform%20the%20command%20on)). Only use this if you intend to have the target environment mirror your local files exactly. It’s best used in scenarios where you maintain full config as code and want to eliminate any out-of-band changes. If used incorrectly, it could surprise team members by moving their config changes out. Always specify a specific service with `-s` when using reconcile (the CLI will force you to, as a safety measure ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,reconcile%60%20flag)) ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=%2A%20New%20option%20%60,reconcile%60%20flag))), and perhaps start with a dry-run to see what it would do.

- **Quiet and JSON for CI:** In a CI environment, you typically want machine-readable output and less noise. Use the `--json` option so that you can programmatically parse the results. For example, your script can parse the JSON to decide whether to fail the build (if any item has `"status": "Failed"`). Also consider `--quiet` to avoid verbose logs, unless you need them for debugging. As noted, the CLI outputs logs vs data on separate streams ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,file%2C%20publish)), so capturing the JSON is straightforward. This design means you can, for instance, do `ugs deploy . -j > deploy_results.json` and you’ll get a clean JSON file of the outcomes while any warnings went to the console log.

- **Error handling and verification:** Always check the exit code of the `ugs deploy` command. In scripting, if it returns non-zero, treat it as a failure and investigate. Additionally, even if the CLI returns zero (success), you might want to verify critical deployments by querying the service or using `ugs fetch` to double-check the deployed state. For example, after a deploy, a quick `ugs fetch RemoteConfig -j` could retrieve the config and you can diff it against your file to ensure consistency. This may be overkill for every deploy, but for production pushes or scheduled audits, it’s a good practice.

- **Keep CLI updated:** Unity may update the UGS CLI with new features or fixes (for example, support for new services, or improvements in deploy behaviors). Ensure your pipeline or dev environment uses a known good version. If you install via npm (`npm install -g ugs`), lock the version in your CI to avoid unexpected changes. Check Unity’s changelog periodically for updates that might affect your deploy process (e.g., changes in output format or new required flags as seen in the beta updates ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,reconcile%60%20flag)) ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,module.exports.parameters%20%3D))).

## Wrapper Implementation Considerations

If you plan to integrate `ugs deploy` into a higher-level tool or an AI-driven system (for example, an LLM-driven devops agent that can call CLI tools), there are some important considerations to handle:

- **Prerequisite Setup (Authentication & Environment):** The wrapper should ensure that the environment is ready to run `ugs deploy`. This means authenticating the CLI and specifying the project and environment. For instance, the wrapper might need to load service account credentials (from a secure store or environment variables) and either call `ugs login` or set the `UGS_CLI_SERVICE_KEY_ID/SECRET_KEY` env vars before invoking deploy ([Login | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/login/#:~:text=To%20log%20in%20manually%20use,command)) ([Login | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/login/#:~:text=To%20log%20in%20with%20system,to%20your%20system%27s%20environment%20variables)). It should also specify which project and environment to target – perhaps by setting env vars or adding `-p/--project-id` and `-e/--environment-name` options to the command. **Never assume the CLI is already logged in or pointed at the correct project** – a robust wrapper initializes these settings to avoid accidentally deploying to the wrong place or hitting auth errors.

- **Parameter Handling and Defaults:** If your LLM tool might call `deploy` without explicit parameters, decide how to handle that. You might have a default directory that contains the config to deploy, or you might require the user/LLM to specify a path. If no path is given, you could default to `.` (current directory), but ensure the working directory is correct. Similarly, if no environment is specified, you might default to a safe environment like “development” to avoid accidental production changes. Being explicit is better: the wrapper can enforce that the LLM’s request includes necessary context (project ID, environment, path) or inject those based on a configured context.

- **Error Handling and Feedback:** When the deploy command runs, the wrapper should capture both its output and exit code. If the process fails (non-zero exit), parse the error message and decide how to relay that back. For example, if `ugs deploy` returns an authentication error, the wrapper could catch it and prompt for correct credentials or abort with a clear message. If a particular file failed (the JSON output will indicate which one and why), the wrapper/LLM could use that to inform the user which part of the deployment failed. Implement timeouts or safeguards as well – if the deploy is taking too long or hanging (perhaps due to network issues), the wrapper should handle that scenario to avoid indefinitely stuck processes.

- **Parsing JSON Output:** If the wrapper needs to use the results (which is likely in an automated scenario), always run with `--json` and parse the stdout. This will give your code a reliable way to understand what happened ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=environment,to%20perform%20the%20command%20on)). The JSON might contain arrays of deployed items; ensure the wrapper can iterate through them and detect any with a failure status. It could also summarize the results (e.g., “5 Remote Config entries updated, 1 new Cloud Code script created, 2 items failed”) for the user if needed. Since the CLI prints logs to stderr, you might want to suppress or separate those if they are not needed, focusing only on JSON from stdout.

- **Idempotency and Repeated Calls:** If the LLM tool might call `deploy` multiple times in succession (maybe as it iteratively works on configurations), consider that running deploy on the same files repeatedly should generally be safe (it will usually report “No change” or leave things unchanged if the input didn’t change). However, be mindful of any side effects. The wrapper might implement a check to skip calling deploy if nothing has changed in the files since the last call, to reduce unnecessary API calls. Additionally, if multiple deploy commands could run in parallel (though unlikely, as one LLM at a time), implement a lock or queue to avoid race conditions.

- **Security and Permissions:** When integrating into an AI or tool, ensure that the context in which `ugs deploy` runs is secure. The service account used should have only the permissions needed (principle of least privilege – e.g., if the tool never needs to deploy Economy settings, you might restrict the account from economy admin roles). Also, avoid exposing the service account secret in logs or error messages. The wrapper should handle secrets carefully (e.g., load from environment variables or a vault, not hard-coded). If the LLM input includes project or environment info, validate it against allowed values – you might not want an AI accidentally deploying to a production environment unless explicitly intended.

- **Environment Specifics:** The wrapper might allow specifying which Unity environment to deploy to (since UGS has multiple environments). If the LLM is selecting the environment, ensure it uses correct names and maybe validate them. A good practice is to have the wrapper configured with known environment names (dev, staging, prod, etc.) and possibly require a higher confirmation or different workflow for production. This can prevent mistakes where an LLM thinks “deploy to production” is a good idea at an unsafe time.

- **Logging and Telemetry:** When an LLM-driven tool is making changes, logging is important for auditing. Ensure that the output from `ugs deploy` (especially with `--json`) is recorded somewhere, or turned into a user-friendly report. This helps in troubleshooting later. Unity’s CLI by default may send telemetry unless disabled; if using in automation, you might disable telemetry with the `UGS_CLI_TELEMETRY_DISABLED` env var ([Configuration Keys | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/configuration/configuration-keys/#:~:text=%60project,Disables%20sending%20telemetry%20when%20set)) for consistency and privacy.

- **Fallbacks and Retries:** The wrapper could implement retries for transient failures (like network timeouts). Since Unity’s services are cloud-based, a deploy could fail due to a temporary connectivity issue. A simple retry mechanism (perhaps retry once or twice with a short delay for certain error types) can make the system more robust. Just be careful to not retry on logical errors (like “invalid JSON”) – those need user/action fix, not a retry.

By handling these considerations, integrating `ugs deploy` into an automated or AI-driven tool can be smooth and reliable. The goal is to abstract the complexity from the end-user (or from the LLM) and ensure that whenever the deploy command is invoked, it has all the info it needs and any problems are caught and managed. This way, the powerful capabilities of Unity UGS CLI can be safely exposed to higher-level systems, enabling scenario like an LLM saying "Deploy the latest game configs to staging," and the wrapper taking care of all the behind-the-scenes steps to make that happen.

**Sources:**

- Unity Gaming Services CLI documentation – **Deploy Command** (supported services, usage, and options) ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=The%20Deploy%20command%20is%20an,supported%20services%20to%20the%20backend)) ([Deploy | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/deploy/#:~:text=Alias%20Description%20project,to%20perform%20the%20command%20on))  
- Unity Gaming Services CLI documentation – **Login and Configuration** (service account auth and project/environment context) ([Login | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/login/#:~:text=To%20log%20in%20manually%20use,command)) ([Configuration Keys | Unity Services Web API docs](https://services.docs.unity.com/guides/ugs-cli/latest/general/base-commands/configuration/configuration-keys/#:~:text=ConfigKey%20EnvironmentKey%20Meaning%20%60project,Disables%20sending%20telemetry%20when%20set))  
- Unity UGS CLI Sample Instructions (examples of deploying various services’ configurations) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=ugs%20deploy%20)) ([unity-gaming-services-cli/Samples/Deploy/instructions.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/Samples/Deploy/instructions.md#:~:text=There%20are%204%20file%20formats,for%20Economy))  
- Unity UGS CLI Changelog (notes on `--services`, `--reconcile`, JSON output behavior, etc.) ([unity-gaming-services-cli/CHANGELOG.md at main · Unity-Technologies/unity-gaming-services-cli · GitHub](https://github.com/Unity-Technologies/unity-gaming-services-cli/blob/main/CHANGELOG.md#:~:text=,reconcile%60%20flag))